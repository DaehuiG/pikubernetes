[main.py]
import os
import dotenv
from fastapi import FastAPI

import routers
from db import database, models

dotenv.load_dotenv()

app = FastAPI(root_path=os.environ.get('BASE_URL', ''))

app.include_router(routers.data.router)
app.include_router(routers.worldcup.maker.router)
app.include_router(routers.worldcup.simulator.router)
app.include_router(routers.health.router)
app.include_router(routers.home.router)

# DB Event
@app.on_event("startup")
async def startup():
    async with database.engine.begin() as conn:
        await conn.run_sync(models.Base.metadata.create_all)

[worldcup_simulator/models.py]
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class WorldCup(Base):
    __tablename__ = "world_cups"

    id = Column(Integer, primary_key=True, index=True)
    current_round = Column(Integer)
    current_round_sub = Column(Integer)
    current_matchup_id = Column(Integer, ForeignKey('image_items.id'))
    current_matchup = relationship("ImageItem", foreign_keys=[current_matchup_id])
    items = relationship("ImageItem", back_populates="world_cup", foreign_keys="ImageItem.world_cup_id")


class ImageItem(Base):
    __tablename__ = "image_items"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    url = Column(String)
    data_entry_id = Column(Integer, ForeignKey('data_entries.id'))
    data_entry = relationship("DataEntry", back_populates="items")
    world_cup_id = Column(Integer, ForeignKey('world_cups.id'))
    world_cup = relationship("WorldCup", back_populates="items", foreign_keys=[world_cup_id])


class DataEntry(Base):
    __tablename__ = "data_entries"

    id = Column(Integer, primary_key=True, index=True)
    description = Column(String, index=True)
    queries = Column(String)
    img_links = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    items = relationship("ImageItem", back_populates="data_entry")


[worldcup_simulator/services.py]
from fastapi import HTTPException
from db import crud
from worldcup_simulator.models import WorldCup, ImageItem
from sqlalchemy.ext.asyncio import AsyncSession
import random

world_cups = {}

async def start_world_cup(session_id: str, id: int, db: AsyncSession) -> WorldCup:
    from_db_items = await crud.get_image_items(db, int(id))
    if not from_db_items:
        raise HTTPException(status_code=404, detail="World Cup not found")
    items = [ImageItem(name=data.name, url=data.url) for data in from_db_items]
    random.shuffle(items)
    
    initial_matchup = (items[0], items[1])
    world_cup = WorldCup(id=session_id, items=items, current_round=len(items), current_round_sub=0, current_matchup=initial_matchup)
    world_cups[session_id] = world_cup
    return world_cup

def make_choice(session_id: str, choice: int) -> WorldCup:
    if session_id not in world_cups:
        raise HTTPException(status_code=404, detail="World Cup not started")

    world_cup = world_cups[session_id]
    if choice == 0:
        lose = 1
    else:
        lose = 0

    if len(world_cup.items) == 1:
        raise HTTPException(status_code=400, detail="No more matchups available")
    
    world_cup.items[2*world_cup.current_round_sub+lose] = None
    if world_cup.current_round_sub < world_cup.current_round // 2 - 1:
        world_cup.current_round_sub += 1
        world_cup.current_matchup = (world_cup.items[world_cup.current_round_sub*2], world_cup.items[world_cup.current_round_sub*2+1])
    else:
        world_cup.current_round //= 2
        world_cup.current_round_sub = 0
        world_cup.items = [item for item in world_cup.items if item is not None]
        random.shuffle(world_cup.items)
        if world_cup.current_round == 1:
            world_cup.current_matchup = (world_cup.items[0], world_cup.items[0])
        else:
            world_cup.current_matchup = (world_cup.items[world_cup.current_round_sub*2], world_cup.items[world_cup.current_round_sub*2+1])
    return world_cup

def get_current_info(session_id: str) -> WorldCup:
    if session_id not in world_cups:
        raise HTTPException(status_code=404, detail="World Cup not started")
    return world_cups[session_id]

def end_world_cup(session_id: str):
    if session_id in world_cups:
        del world_cups[session_id]


[worldcup_simulator/schemas.py]
from pydantic import BaseModel
from typing import List, Tuple, Optional

class StartRequest(BaseModel):
    id: str

class ChoiceRequest(BaseModel):
    choice: int

class ImageInfo(BaseModel):
    name: str
    url: str

class InfoResponse(BaseModel):
    session_id: str
    current_round: int
    current_round_sub: int
    current_matchup: Tuple[ImageInfo, ImageInfo]

class ImageItemBase(BaseModel):
    name: str
    url: str

class ImageItem(ImageItemBase):
    id: int
    world_cup_id: int

    class Config:
        orm_mode = True

class WorldCupBase(BaseModel):
    current_round: int
    current_round_sub: int

class WorldCupCreate(WorldCupBase):
    items: List[ImageItem]

class WorldCup(WorldCupBase):
    id: int
    current_matchup: Optional[ImageItem]
    items: List[ImageItem]

    class Config:
        orm_mode = True

class GenerateCandidatesRequest(BaseModel):
    prompt: str
    num_candidates: int

class GenerateCandidatesResponse(BaseModel):
    candidates: List[str]

class DataRequestForm(BaseModel):
    description: str
    candidates: List[str]

class CompareRequest(BaseModel):
    description: str

class CompareResponse(BaseModel):
    similar_descriptions: List[Tuple[int, str]]

[worldcup_maker/service.py]
import openai
import os
import requests
import re
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env')
load_dotenv(dotenv_path=env_path)

openai_api_key = os.getenv('gptApiKey')
client = openai.OpenAI(api_key=openai_api_key)

def get_top_image_urls(queries):
    api_key = os.getenv('googleSearchKey')
    cse_id = os.getenv('googleCSEId')
    result = []

    for query in queries:
        url = f"https://www.googleapis.com/customsearch/v1?q={query}&cx={cse_id}&key={api_key}&searchType=image&num=1"
        response = requests.get(url)
        data = response.json()
        if 'items' in data and data['items']:
            image_url = data['items'][0]['link']
            result.append((query, image_url))
        else:
            result.append((query, "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQC0Mop6s6wJ2kNSKyAcHQRIjweaHlsr1Cv8CqijMIZBg&s"))
    return result

def generate_candidates(prompt, num_candidates):
    full_prompt = f"Create a list of {num_candidates} candidates for: {prompt}. Surround each candidate with <>. If the prompt is in Korean, generate candidates in Korean; if it is in English, generate candidates in English. Also, ensure the candidates are unique."
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": full_prompt}
        ],
        max_tokens=1000,
        temperature=0.7
    )
    return response.choices[0].message.content

def extract_bracketed_strings(text):
    return [match for match in re.findall(r'<(.*?)>', text) if match.strip()]

def compare_descriptions(input_description, all_descriptions):
    prompt = f"Compare the following description with the provided list and find those with the same meaning:\n\nInput Description:\n{input_description}\n\nList of Descriptions:\n"
    for id, description in all_descriptions:
        prompt += f"{id}: {description}\n"
    
    prompt += "\nReturn the IDs and descriptions of the entries that have the same meaning as the input description."

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=1000,
        temperature=0.7
    )
    
    result_text = response.choices[0].message.content
    same_meaning_descriptions = re.findall(r'(\d+): ([^\n]+)', result_text)
    return [(int(id), desc) for id, desc in same_meaning_descriptions]


[routers/health.py]
from fastapi import APIRouter

router = APIRouter(tags=['health'])

@router.get('/_health')
async def get_health():
    return {'status': 'Ok'}


[routers/data.py]
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from db import crud, schemas as db_schemas, database
from worldcup_maker.service import get_top_image_urls, compare_descriptions
from worldcup_simulator.schemas import DataRequestForm, CompareRequest, CompareResponse
import openai

router = APIRouter(
    tags=['data'],
)

@router.post("/data_entries_from_queries/", response_model=db_schemas.DataEntry)
async def create_data_entry_from_queries(data: DataRequestForm, db: AsyncSession = Depends(database.get_db)):
    try:
        image_data = get_top_image_urls(data.candidates)
        data_entry_create = db_schemas.DataEntryCreate(
            description=data.description,
            data=image_data
        )
        new_entry = await crud.create_data_entry(db, data_entry_create)
        return db_schemas.DataEntry.from_orm(new_entry)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/data_entry_summaries/", response_model=db_schemas.DataEntrySummaryList)
async def get_data_entry_summaries(db: AsyncSession = Depends(database.get_db)):
    summaries = await crud.get_data_entry_summary(db)
    if not summaries:
        raise HTTPException(status_code=404, detail="No data entries found")
    return {"summaries": summaries}

@router.put("/data_entries/{entry_id}/", response_model=db_schemas.DataEntrySummary)
async def update_data_entry(entry_id: int, data: DataRequestForm, db: AsyncSession = Depends(database.get_db)):
    image_data = get_top_image_urls(data.candidates)
    data_entry_update = db_schemas.DataEntryCreate(
        description=data.description,
        data=image_data
    )
    updated_entry = await crud.update_data_entry(db, entry_id, data_entry_update)
    if not updated_entry:
        raise HTTPException(status_code=404, detail="Data entry not found")
    return updated_entry

@router.post("/compare_description/", response_model=CompareResponse)
async def compare_description(request: CompareRequest, db: AsyncSession = Depends(database.get_db)):
    all_descriptions = await crud.get_all_descriptions(db)
    similar_descriptions = compare_descriptions(request.description, all_descriptions)
    return CompareResponse(similar_descriptions=similar_descriptions)

[routers/home.py]
from fastapi import APIRouter

router = APIRouter(tags=['home'])

@router.get('/')
async def get_root():
    return {'name': 'Your-Backend-Service'}


[routers/__init__.py]
from . import (  # noqa: F401
    data,
    health,
    home,
    worldcup,
)


[routers/worldcup/simulator.py]
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from worldcup_simulator.services import start_world_cup, make_choice, get_current_info, end_world_cup
from worldcup_simulator.schemas import (
    StartRequest, ChoiceRequest, InfoResponse, 
    ImageInfo
)
import uuid
from db import database

router = APIRouter(tags=['worldcup'])

@router.post("/start", response_model=InfoResponse)
async def start(request: StartRequest, db: AsyncSession = Depends(database.get_db)):
    session_id = str(uuid.uuid4())
    world_cup = await start_world_cup(session_id, request.id, db)
    return InfoResponse(
        session_id=session_id,
        current_round=world_cup.current_round, 
        current_round_sub=world_cup.current_round_sub,
        current_matchup=(
            ImageInfo(name=world_cup.current_matchup[0].name, url=world_cup.current_matchup[0].url),
            ImageInfo(name=world_cup.current_matchup[1].name, url=world_cup.current_matchup[1].url)
        )
    )

@router.post("/choice", response_model=InfoResponse)
async def choice(request: ChoiceRequest, session_id: str):
    world_cup = make_choice(session_id, request.choice)
    return InfoResponse(
        session_id=session_id,
        current_round=world_cup.current_round,
        current_round_sub=world_cup.current_round_sub,
        current_matchup=(
            ImageInfo(name=world_cup.current_matchup[0].name, url=world_cup.current_matchup[0].url),
            ImageInfo(name=world_cup.current_matchup[1].name, url=world_cup.current_matchup[1].url)
        )
    )

@router.get("/info/{session_id}", response_model=InfoResponse)
async def info(session_id: str):
    world_cup = get_current_info(session_id)
    return InfoResponse(
        session_id=session_id,
        current_round=world_cup.current_round, 
        current_round_sub=world_cup.current_round_sub,
        current_matchup=(
            ImageInfo(name=world_cup.current_matchup[0].name, url=world_cup.current_matchup[0].url),
            ImageInfo(name=world_cup.current_matchup[1].name, url=world_cup.current_matchup[1].url)
        )
    )

@router.post("/end/{session_id}")
async def end(session_id: str):
    end_world_cup(session_id)
    return {"message": "World Cup ended"}


[routers/worldcup/__init__.py]
from . import maker, simulator  # noqa: F401


[routers/worldcup/maker.py]
from fastapi import APIRouter
from worldcup_maker.service import generate_candidates, extract_bracketed_strings
from worldcup_simulator.schemas import GenerateCandidatesRequest, GenerateCandidatesResponse

router = APIRouter(tags=['worldcup'])

@router.post("/generate_candidates", response_model=GenerateCandidatesResponse)
async def generate_candidates_endpoint(request: GenerateCandidatesRequest):
    candidates_text = generate_candidates(request.prompt, request.num_candidates)
    candidates = extract_bracketed_strings(candidates_text)
    return GenerateCandidatesResponse(candidates=candidates)


[db/database.py]
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from .config import DATABASE_URL

engine = create_async_engine(DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session


[db/models.py]
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class DataEntry(Base):
    __tablename__ = "data_entries"

    id = Column(Integer, primary_key=True, index=True)
    description = Column(String, index=True)
    queries = Column(String)
    img_links = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    items = relationship("ImageItem", back_populates="data_entry")

class ImageItem(Base):
    __tablename__ = "image_items"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    url = Column(String)
    data_entry_id = Column(Integer, ForeignKey('data_entries.id'))
    data_entry = relationship("DataEntry", back_populates="items")


[db/config.py]
import os
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env')
load_dotenv(dotenv_path=env_path)

DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+asyncpg://postgres:1234@piku-postgres:5434/piku")


[db/crud.py]
from http.client import HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import update
from . import models, schemas
from fastapi.logger import logger

async def create_data_entry(db: AsyncSession, data_entry: schemas.DataEntryCreate):
    try:
        queries = [item[0] for item in data_entry.data]
        img_links = [item[1] for item in data_entry.data]
        
        db_entry = models.DataEntry(
            description=data_entry.description,
            queries=",".join(queries),
            img_links=",".join(img_links)
        )
        db.add(db_entry)
        await db.commit()
        await db.refresh(db_entry)
        logger.info(f"Data entry saved to DB: {db_entry}")
        return db_entry
    except Exception as e:
        logger.error(f"Error saving data entry: {e}")
        raise HTTPException(status_code=500, detail="Internal Server Error")

async def get_data_entry(db: AsyncSession, entry_id: int):
    result = await db.execute(select(models.DataEntry).filter(models.DataEntry.id == entry_id))
    db_entry = result.scalars().first()
    if db_entry:
        db_entry.queries = db_entry.queries.split(",") if db_entry.queries else []
        db_entry.img_links = db_entry.img_links.split(",") if db_entry.img_links else []
    return db_entry

async def get_image_items(db: AsyncSession, id: int):
    result = await db.execute(select(models.DataEntry).filter(models.DataEntry.id == id))
    data_entry = result.scalars().first()
    if not data_entry:
        return []

    queries = data_entry.queries.split(',')
    img_links = data_entry.img_links.split(',')

    return [
        models.ImageItem(name=query, url=img_link)
        for query, img_link in zip(queries, img_links)
    ]

async def get_data_entry_summary(db: AsyncSession):
    result = await db.execute(
        select(models.DataEntry.id, models.DataEntry.description, models.DataEntry.created_at)
    )
    summaries = result.all()
    return [
        {
            "id": summary.id,
            "description": summary.description,
            "created_at": summary.created_at
        }
        for summary in summaries
    ]

async def update_data_entry(db: AsyncSession, entry_id: int, data_entry: schemas.DataEntryCreate):
    queries = [item[0] for item in data_entry.data]
    img_links = [item[1] for item in data_entry.data]
    
    result = await db.execute(
        update(models.DataEntry)
        .where(models.DataEntry.id == entry_id)
        .values(
            description=data_entry.description,
            queries=",".join(queries),
            img_links=",".join(img_links)
        )
        .returning(models.DataEntry.id, models.DataEntry.description, models.DataEntry.created_at)
    )
    updated_entry = result.first()
    await db.commit()
    
    if updated_entry:
        return {
            "id": updated_entry.id,
            "description": updated_entry.description,
            "created_at": updated_entry.created_at
        }
    return None

async def get_all_descriptions(db: AsyncSession):
    result = await db.execute(
        select(models.DataEntry.id, models.DataEntry.description)
    )
    return result.all()


[db/schemas.py]
from pydantic import BaseModel
from typing import List, Tuple
from datetime import datetime

class DataEntryBase(BaseModel):
    description: str

class DataEntryCreate(DataEntryBase):
    data: List[Tuple[str, str]]

class DataEntry(DataEntryBase):
    id: int
    description: str
    queries: List[str]                
    img_links: List[str]
    created_at: datetime

    class Config:
        orm_mode = True
        from_attributes = True

    @classmethod
    def from_orm(cls, obj):
        obj.queries = obj.queries.split(",") if obj.queries else []
        obj.img_links = obj.img_links.split(",") if obj.img_links else []
        return super().from_orm(obj)

class DataEntrySummary(BaseModel):
    id: int
    description: str
    created_at: datetime

class DataEntrySummaryList(BaseModel):
    summaries: List[DataEntrySummary]


[front_simple_test/front.py]
import streamlit as st
import requests

# 서버 URL 설정
BASE_URL = "http://34.41.189.95:8000"

# 세션 상태 유지
if 'session_id' not in st.session_state:
    st.session_state.session_id = None
if 'current_round' not in st.session_state:
    st.session_state.current_round = 0
if 'current_round_sub' not in st.session_state:
    st.session_state.current_round_sub = 0
if 'current_matchup' not in st.session_state:
    st.session_state.current_matchup = None
if 'home' not in st.session_state:
    st.session_state.home = True
if 'new_worldcup_id' not in st.session_state:
    st.session_state.new_worldcup_id = None
if 'candidates' not in st.session_state:
    st.session_state.candidates = []
if 'creating_worldcup' not in st.session_state:
    st.session_state.creating_worldcup = False
if 'num_candidates' not in st.session_state:
    st.session_state.num_candidates = 16

def load_data_entry_summaries():
    try:
        response = requests.get(f"{BASE_URL}/data_entry_summaries/")
        response.raise_for_status()  # HTTPError가 발생하는지 확인
        return response.json()['summaries']
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred: {e}")
        return []

def start_worldcup(entry_id):
    try:
        response = requests.post(f"{BASE_URL}/start", json={"id": str(entry_id)})
        response.raise_for_status()  # HTTPError가 발생하는지 확인
        data = response.json()
        st.session_state.session_id = data['session_id']
        st.session_state.current_round = data['current_round']
        st.session_state.current_round_sub = data['current_round_sub']
        st.session_state.current_matchup = data['current_matchup']
        st.session_state.home = False
        st.experimental_rerun()  # 상태 변경 후 재실행
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred: {e}")
        st.error(f"Response content: {response.content}")

def make_choice(choice):
    session_id = st.session_state.session_id
    try:
        response = requests.post(f"{BASE_URL}/choice?session_id={session_id}", json={"choice": choice})
        response.raise_for_status()  # HTTPError가 발생하는지 확인
        data = response.json()
        st.session_state.current_round = data['current_round']
        st.session_state.current_round_sub = data['current_round_sub']
        st.session_state.current_matchup = data['current_matchup']
        st.experimental_rerun()  # 상태 변경 후 재실행
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred: {e}")
        st.error(f"Response content: {response.content}")

def generate_candidates(prompt, num_candidates):
    try:
        response = requests.post(f"{BASE_URL}/generate_candidates", json={"prompt": prompt, "num_candidates": num_candidates})
        response.raise_for_status()  # HTTPError가 발생하는지 확인
        return response.json()['candidates']
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred: {e}")
        return []

def create_new_worldcup(description, candidates):
    try:
        payload = {"description": description, "candidates": candidates}
        st.write("Request Payload:", payload)  # 요청 페이로드 출력
        response = requests.post(f"{BASE_URL}/data_entries_from_queries/", json=payload)
        response.raise_for_status()  # HTTPError가 발생하는지 확인
        return response.json()
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred: {e}")
        return None

def update_worldcup(entry_id, description, candidates):
    try:
        response = requests.put(f"{BASE_URL}/data_entries/{entry_id}/", json={"description": description, "candidates": candidates})
        response.raise_for_status()  # HTTPError가 발생하는지 확인
        return response.json()
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred: {e}")
        return None

def reset_home():
    st.session_state.home = True
    st.session_state.session_id = None
    st.session_state.current_round = 0
    st.session_state.current_round_sub = 0
    st.session_state.current_matchup = None
    st.session_state.new_worldcup_id = None
    st.session_state.candidates = []
    st.session_state.creating_worldcup = False
    st.experimental_rerun()

# UI 구성
st.title("이상형 월드컵")

if st.session_state.home:
    if st.button("Play World Cup", key="play_worldcup"):
        st.session_state.home = False
        st.experimental_rerun()
    if st.button("Make World Cup", key="make_worldcup"):
        st.session_state.home = False
        st.session_state.creating_worldcup = True
        st.experimental_rerun()
else:
    if st.session_state.creating_worldcup:
        prompt = st.text_input("새로운 월드컵의 주제를 입력하세요 (예: 연예인, 애니메이션 등):", key="worldcup_prompt")
        num_candidates = st.selectbox("후보 개수를 선택하세요:", [4, 8, 16, 32, 64], index=1, key="num_candidates")
        if st.button("후보 생성하기", key="generate_candidates"):
            candidates = generate_candidates(prompt, num_candidates)
            if candidates:
                new_worldcup = create_new_worldcup(prompt, candidates)
                if new_worldcup:
                    st.session_state.new_worldcup_id = new_worldcup['id']
                    st.session_state.candidates = candidates
                    start_worldcup(new_worldcup['id'])
                    st.session_state.creating_worldcup = False
                    st.experimental_rerun()
    elif st.session_state.session_id is None:
        summaries = load_data_entry_summaries()
        if summaries:
            st.write("플레이 할 월드컵을 선택하세요:")
            for summary in summaries:
                if st.button(f"{summary['description']} (생성일: {summary['created_at']})", key=f"summary_{summary['id']}"):
                    prompt = summary['description']
                    start_worldcup(summary['id'])
        else:
            st.write("사용 가능한 월드컵 데이터가 없습니다.")
            if st.button("홈으로 돌아가기", key="back_to_home"):
                reset_home()

    if st.session_state.current_matchup and st.session_state.current_round != 1:
        st.write(f"현재 라운드: {st.session_state.current_round}, 매치 {st.session_state.current_round_sub + 1}")
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button(f"선택: {st.session_state.current_matchup[0]['name']}", key="choice_0"):
                make_choice(0)
        with col2:
            if st.button(f"선택: {st.session_state.current_matchup[1]['name']}", key="choice_1"):
                make_choice(1)
        
        try:
            col1.image(st.session_state.current_matchup[0]['url'], use_column_width=True)
        except Exception as e:
            col1.error(f"Error loading image: {e}")
        try:
            col2.image(st.session_state.current_matchup[1]['url'], use_column_width=True)
        except Exception as e:
            col2.error(f"Error loading image: {e}")

    if st.session_state.current_round == 1:
        st.balloons()
        st.success(f"최종 선택: {st.session_state.current_matchup[0]['name']}")
        try:
            st.image(st.session_state.current_matchup[0]['url'], use_column_width=True)
        except Exception as e:
            st.error(f"Error loading image: {e}")
        if st.button("후보 수정하기", key="edit_candidates"):
            st.session_state.session_id = None
            st.experimental_rerun()
        if st.button("홈으로 돌아가기", key="home_after_final"):
            reset_home()

    if st.session_state.new_worldcup_id and not st.session_state.session_id:
        st.write("후보를 수정하세요:")
        updated_candidates = []
        for i, candidate in enumerate(st.session_state.candidates):
            updated_candidate = st.text_input(f"후보:", value=candidate, key=f"candidate_{i}")
            updated_candidates.append(updated_candidate)
        
        if st.button("후보 수정하기", key="update_candidates"):
            updated_worldcup = update_worldcup(st.session_state.new_worldcup_id, prompt, updated_candidates)
            if updated_worldcup:
                st.success("후보가 성공적으로 수정되었습니다.")
                st.session_state.new_worldcup_id = None
                st.session_state.candidates = []
                if st.button("홈으로 돌아가기", key="home_after_update"):
                    reset_home()


